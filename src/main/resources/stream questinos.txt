üî∏ Java 8 Coding Practice Using Employee Class
‚úÖ Basic Stream Operations
Print all employee names

List employees with salary > 50,000

Sort employees by salary (descending)

Sort employees by name alphabetically

Remove duplicate employees based on name

‚úÖ Grouping & Aggregation
Group employees by department
Map<Integer, List<Employee>>

Count employees in each department
Map<Integer, Long>

Find highest-paid employee in each department

Calculate average salary of all employees

Find employee with the highest salary

‚úÖ Filtering and Mapping
Get names of employees with salary between 30k‚Äì60k

Convert names to uppercase list

Check if any employee earns > 1 lakh

Check if all employees belong to same department

Find employees whose names start with 'A'

‚úÖ Advanced Stream + Optional
Get employee by name using Optional
Return "Not Found" if absent

Safely get employee salary using Optional
Return default if null

Comma-separated string of all employee names

Partition employees based on salary > 50,000
Map<Boolean, List<Employee>>

Get distinct department IDs as list

‚úÖ Method References & Constructor Reference
Use method reference to print all employee names

Create new list of employees using constructor reference

‚úÖ Parallel Stream and Performance
Use parallel stream to count salary > 60,000

Compare performance: stream() vs parallelStream()

‚úÖ Functional Interfaces
Write Predicate<Employee> for salary > 40k

Use Function<Employee, String> to extract name

Use Consumer<Employee> to print details

Use Supplier<Employee> for dummy employee

üß† Real-World / Advanced Scenarios
Find second-highest salary employee

Find department with maximum employees

Top 3 earners in the organization

Remove duplicate employees by name (keep first only)

‚è±Ô∏è Date & Time API
Print joining date in dd-MM-yyyy format

Count employees joined after specific date

---------------------------------------------------------

advance level questions 

‚úÖ Basic Stream Operations (Level 1)
Print all employee names.

Get a list of employees whose salary is greater than 50,000.

Sort employees by name alphabetically.

Sort employees by salary descending.

Remove duplicate employees by name.

Convert list of employees to a list of names.

Convert list of employees to Map<id, name>.

Filter employees who joined after 2021.

Get all employees with department "IT".

Get count of employees with salary below 40,000.

‚úÖ Intermediate: Grouping, Aggregation, Transformation (Level 2)
Group employees by department.

Count employees per department.

Average salary per department.

Find the department with the max employees.

Find the highest-paid employee in each department.

List departments with average salary > 60k.

Create Map<DepartmentName, List<Employee>> sorted by department name.

Partition employees by salary > 60k.

Find duplicate employee names.

Create comma-separated string of employee names.

Get summary of salaries (min, max, avg, sum, count).

Join all employee names in uppercase with commas.

Sort employees by department, then by name.

Convert list of employee names to a Set.

List employees whose names start with ‚ÄòA‚Äô.

Check if any employee earns more than 1L.

Check if all employees belong to the same department.

Get list of departments sorted by number of employees.

Get list of all unique department names.

Get employee by ID using Optional (return "Unknown" if absent).

‚úÖ Advanced Use Cases (Level 3)
Find the second-highest salary employee.

Find employees with salary equal to max salary.

List top 3 highest-paid employees.

Get employees joined in the last 2 years.

Count employees in each department with salary > 50k.

Create Map<Department, Employee> with highest salary in each.

Remove duplicate employees by name (keep first).

Get total salary paid per department.

Find youngest and oldest employee by joining date.

Partition employees into before and after 2020.

Convert employee list to TreeMap<DeptId, Set<EmployeeName>>.

Check if any two employees have the same salary.

Find all employee names sorted in reverse alphabetical order.

Create Map<EmployeeName, List<Salary>> for duplicate names.

Find department with lowest average salary.

Convert list to LinkedHashMap with insertion order maintained.

Group employee names by department into a comma-separated string.

Get list of employee objects whose salary is in top 20%.

Sort employees by ID but keep duplicates by name removed.

Return employees with min and max salary in one pass.

Create List<String> as ‚ÄúAlice - HR‚Äù, ‚ÄúBob - Finance‚Äù.

Filter and collect employee names with salary divisible by 10k.

Get employee with highest salary in "HR" department.

Map<EmployeeId, Employee> keeping the latest joined employee for duplicate IDs.

Get distinct list of salaries in sorted order.

Filter employees whose name has more than 5 characters.

Find common salary among 2 different department employees.

Create a Map<Year, List<Employee>> based on joining year.

List employees grouped by month of joining.

Print names of employees who joined on weekends.

Get average salary of employees whose name starts with vowel.

‚úÖ Bonus: Functional Interface Practice
Write a Predicate<Employee> for salary > 50,000.

Use Function<Employee, String> to return ‚Äúname - department‚Äù.

Use Consumer<Employee> to print name and joining date.

Create a Supplier<Employee> that returns a dummy employee.

Chain two Consumer<Employee> using andThen()


-----------------------------------

Group employees by department and find the highest-paid employee in each department.

From a list of people, find the youngest person per city.

Group products by category and find the total revenue per category.

Group a list of students by grade and collect only those who scored more than 80.

Find the department with the highest average salary.

Partition employees by whether they joined before or after 2020 and find average salaries in both groups.

Group orders by customer and collect all product names into a single comma-separated string.

Create a Map<City, List<Employee>> sorted by city name and sort employees in each list by salary (descending).

For each department, find the employee with the earliest joining date.

From a list of transactions, group by year and month, and count transactions per period.

Sorting & Complex Reductions
Find the top 3 highest-paid employees across all departments.

Sort employees by salary (desc), then by name (asc) within the same salary.

Find the employee whose salary is the median.

Find the second-highest salary without using skip() or limit().

Return a list of employees, removing duplicates by name but keeping the one with the highest salary.

Sort transactions first by amount (desc) then by date (asc).

Get the city with the lowest average salary.

From a list of integers, return the three most frequent elements (most occurring).

Find the longest word in a list of sentences (ignoring punctuation).

Find the most common joining year among employees.

Merging, Mapping & Advanced Collectors
Merge two lists of employees, remove duplicates (by ID), and sort by name.

Convert List<Employee> to Map<Department, List<String>> (department to employee names).

From a list of students, create a Map<Grade, Double> with the average score per grade.

Create a Map<Boolean, List<Employee>> partitioned by whether salary > 50,000.

Merge salaries from multiple branches and sum them for each employee ID.

Create a map where the key is joining year, and the value is a Set of cities employees joined from.

Flatten a List<List<Integer>> into a sorted, distinct list.

Combine multiple maps into one (handling duplicate keys by summing values).

Convert Map<String, List<Employee>> to Map<String, Double> (average salary per city).

Group numbers by even and odd, then return the sum for each group.

Challenging Stream Transformations
From a list of sentences, find the top 5 most frequent words.

Remove duplicate words (case-insensitive) from a list of strings, preserving insertion order.

Convert a list of file paths into a unique list of file extensions sorted alphabetically.

For each employee, calculate their annual bonus as 10% of salary and return a Map<Name, BonusAmount>.

From a list of numbers, create pairs (i, j) where i + j == target, without duplicates.

Create a custom collector to concatenate strings with a delimiter and a prefix/suffix.

Given a list of employees with multiple phone numbers, flatten into a single List<String> of all phone numbers.

Implement a collector that counts frequency of each character in a string.

Find all employees who have salaries in the top 10% of the company.

Detect if a list contains any duplicates and return the duplicate elements.

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
level 3 questions
-----------------------------------------------

A. Grouping and Aggregation (1‚Äì15)
Group employees by department and list all employees in each.

Group employees by city and count how many employees per city.

Group employees by department and get the total salary of each group.

Group products by category and get the average price in each category.

Group students by grade and count how many got above 80 marks.

Group orders by customer name and get the total amount spent per customer.

Group books by author and collect book titles into a list.

Group employees by department, then get the employee with the highest salary in each.

Group employees by city and department (multi-level grouping).

Partition employees by whether their salary is greater than 50K, then count each group.

Partition students by whether they passed (marks >= 40), then get average marks for both groups.

Group invoices by month and calculate total billing per month.

Group orders by status (Delivered, Pending, Cancelled) and count.

Group files by extension and get the largest file in each group.

Group products by manufacturer and sort the products in each group by price.

üßπ B. Filtering, Sorting, and Deduplication (16‚Äì25)
Get all employees with salary > 60K and age < 30.

Find top 5 highest-paid employees across all departments.

Find the employee with the earliest joining date.

Get distinct department names in sorted order.

From a list of projects with duplicate names, collect unique names.

Sort employees by salary descending and then by name ascending.

Get employees joined in the last 2 years and sort them by joining date.

Filter out students who failed and sort them by total marks.

Get top 3 customers with highest total purchases.

Remove duplicate email addresses from a list and collect into sorted set.

üß± C. Mapping and FlatMapping (26‚Äì35)
Flatten a list of lists of strings into a single list of strings.

From a list of employees with multiple phone numbers, flatten all phone numbers into one list.

Get all product names from a list of orders (each order has a list of product names).

Convert a list of names into uppercase.

Create a comma-separated string of all product names from a list.

Get a map of employee ID to employee name.

From a list of transactions, extract all transaction IDs.

From a list of blog posts with multiple tags, flatten and get all unique tags.

Map a list of file paths to just file names.

Convert list of Employee objects to list of full names (first + last).

üßÆ D. Collectors and Reduction (36‚Äì45)
Calculate the total salary of all employees.

Get average age of all employees.

Find the highest salary among all employees.

Find the most expensive product.

Count number of orders per product category.

Find the longest word in a list of strings.

From a list of strings, get the frequency of each word.

Calculate the sum of squares of all numbers in a list.

Get a comma-separated string of employee names.

From a list of scores, get summary statistics (min, max, avg, sum).

üîß E. Real-World Use Cases & Tricks (46‚Äì50)
From a list of customers and their orders, get a map of customer ‚Üí total items purchased.

From a map of <Department, List<Employee>>, find top performer per department.

From attendance logs (employee, date), find who was present every weekday in the last week.

Given a list of log entries, filter those with ‚ÄúERROR‚Äù and collect timestamps.

From list of employees, find those who fall in the top 10% by salary.

--------------------------------------------------------------------

üß† Complex Stream API Questions for Practice
‚úÖ 1. Grouping + Filtering + Sorting
Q: Group employees by department, then find top 3 highest-paid employees in each department.

‚úÖ 2. FlatMap + Grouping
Q: Given a list of employees, each with multiple projects, flatten and group project names by city.

‚úÖ 3. Partitioning + Aggregation
Q: Partition employees by those earning more than 50K. For both groups, calculate average and total salary.

‚úÖ 4. Multi-Level Grouping
Q: Group employees by city and then by department. For each group, calculate total salary and count.

‚úÖ 5. Mapping + Reducing
Q: From a list of products, group by category and calculate total price using reducing collector.

‚úÖ 6. CollectingAndThen + Deduplication
Q: From a list of strings, remove duplicates, sort them, and collect into an unmodifiable list.

‚úÖ 7. Custom Collector
Q: Create a custom collector to join names with delimiter ;, add prefix Names: and suffix .

‚úÖ 8. Sorting a Map by Value
Q: `Create a map of department to total salary and sort it in descending order of salary.`

‚úÖ 9. Find the Most Frequent Element
Q: From a list of employee names, find the name that appears most frequently.

‚úÖ 10. Conditional FlatMap
Q: Given a list of employees, each with optional emergency contact numbers (List<Optional<String>>), flatten and collect all non-empty contact numbers.

üß™ Bonus Real-World Scenarios
üì¶ 11. Orders Report
Q: From a list of orders (with customer name, list of product names, and total), generate a map of customer name ‚Üí total spent.

üßæ 12. Invoice Filtering
Q: Filter invoices where due date is before today and amount > 10,000. Then sort by due date.

üìÖ 13. Attendance System
Q: Given a list of attendance records (employeeId, date), find days each employee was absent in the current month.

üìä 14. Top Performer Per City
Q: Group employees by city and get the employee with the highest performance score in each city.

üîÑ 15. Dynamic Filtering
Q: Given dynamic filters like salary > x, department = y, experience > z, filter employees based on the selected filters using stream chaining.